{"version":3,"sources":["../../src/parsers/routeToLocation.js"],"names":["ERRORS","noId","notFound","id","createMatchRouteToPath","params","query","hash","undefined","matcher","registry","pathname","e","toString","location","search","createRouteToLocationParser","routes","reduce","result","item","compile","pattern","path"],"mappings":";;;;;;AAAA;;;;AACA;;AACA;;AACA;;AACA;;;;;;AAEA,IAAMA,SAAS;AACXC,UAAM;AAAA,eAAK,+BAAL;AAAA,KADK;AAEXC,cAAU;AAAA,kCAAuBC,EAAvB;AAAA;AAFC,CAAf;;AAKA,IAAMC,yBAAyB,SAAzBA,sBAAyB;AAAA,WAAY,gBAA+C;AAAA,YAA5CD,EAA4C,QAA5CA,EAA4C;AAAA,+BAAxCE,MAAwC;AAAA,YAAxCA,MAAwC,+BAA/B,EAA+B;AAAA,8BAA3BC,KAA2B;AAAA,YAA3BA,KAA2B,8BAAnB,EAAmB;AAAA,6BAAfC,IAAe;AAAA,YAAfA,IAAe,6BAAR,EAAQ;;AACtF,YAAIJ,OAAOK,SAAX,EAAsB,MAAM,oBAAgBR,OAAOC,IAAP,EAAhB,CAAN;;AAEtB,YAAMQ,UAAUC,SAASP,EAAT,CAAhB;;AAEA,YAAIM,YAAYD,SAAhB,EAA2B,MAAM,oBAAgBR,OAAOE,QAAP,CAAgBC,EAAhB,CAAhB,CAAN;;AAE3B,YAAIQ,iBAAJ;;AAEA,YAAI;AACAA,uBAAWF,QAAQJ,MAAR,CAAX;AACH,SAFD,CAEE,OAAOO,CAAP,EAAU;AACR,kBAAM,oBAAgBA,EAAEC,QAAF,EAAhB,CAAN;AACH;;AAED,YAAMC,WAAW;AACbC,oBAAQ,4BAAYT,KAAZ,CADK;AAEbK,8BAFa;AAGbJ;AAHa,SAAjB;;AAMA,eAAO,yBAAWO,QAAX,CAAP;AACH,KAtB8B;AAAA,CAA/B;;AAwBA,IAAME,8BAA8B,SAA9BA,2BAA8B,SAAU;;AAE1C,QAAMN,WAAW,yBAAcO,MAAd,EAAsBC,MAAtB,CAA6B,UAACC,MAAD,EAASC,IAAT,EAAkB;AAC5D,YAAID,OAAOC,KAAKjB,EAAZ,CAAJ,EAAqB;AACjB,mBAAOgB,MAAP;AACH;AACDA,eAAOC,KAAKjB,EAAZ,IAAkB,uBAAakB,OAAb,CAAqBD,KAAKE,OAAL,CAAaC,IAAlC,CAAlB;AACA,eAAOJ,MAAP;AACH,KANgB,EAMd,EANc,CAAjB;;AAQA,WAAOf,uBAAuBM,QAAvB,CAAP;AACH,CAXD;;kBAaeM,2B","file":"routeToLocation.js","sourcesContent":["import pathToRegexp from 'path-to-regexp';\nimport { stringify as qsStringify } from 'query-string';\nimport { createPath } from 'history';\nimport { flattenRoutes } from './util';\nimport RouterError from '../error';\n\nconst ERRORS = {\n    noId: _ => 'Can\\'t match route with no id',\n    notFound: id => `Route with id ${id} not found`\n};\n\nconst createMatchRouteToPath = registry => ({ id, params = {}, query = {}, hash = ''}) => {\n    if (id === undefined) throw new RouterError(ERRORS.noId());\n\n    const matcher = registry[id];\n\n    if (matcher === undefined) throw new RouterError(ERRORS.notFound(id));\n\n    let pathname;\n\n    try {\n        pathname = matcher(params);\n    } catch (e) {\n        throw new RouterError(e.toString());\n    }\n\n    const location = {\n        search: qsStringify(query),\n        pathname,\n        hash\n    };\n\n    return createPath(location);\n};\n\nconst createRouteToLocationParser = routes => {\n\n    const registry = flattenRoutes(routes).reduce((result, item) => {\n        if (result[item.id]) {\n            return result;\n        }\n        result[item.id] = pathToRegexp.compile(item.pattern.path);\n        return result;\n    }, {});\n\n    return createMatchRouteToPath(registry);\n};\n\nexport default createRouteToLocationParser;"]}